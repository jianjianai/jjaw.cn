import{_ as l,r as s,o as c,c as a,b as t,e,d as i,a as n}from"./app-CcpjxeBW.js";const r={},d=t("h1",{id:"协变与逆变",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#协变与逆变"},[t("span",null,"协变与逆变")])],-1),p={href:"https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance",target:"_blank",rel:"noopener noreferrer"},m={href:"https://en.wikipedia.org/wiki/Subtyping",target:"_blank",rel:"noopener noreferrer"},g=t("em",null,"协变",-1),h=t("em",null,"逆变",-1),k=n('<p>开始文章之前我们先约定如下的标记：</p><ul><li><code>A ≼ B</code> 意味着 <code>A</code> 是 <code>B</code> 的子类型。</li><li><code>A → B</code> 指的是以 <code>A</code> 为参数类型，以 <code>B</code> 为返回值类型的函数类型。</li><li><code>x : A</code> 意味着 <code>x</code> 的类型为 <code>A</code>。</li></ul><h2 id="一个有趣的问题" tabindex="-1"><a class="header-anchor" href="#一个有趣的问题"><span>一个有趣的问题</span></a></h2><p>假设我有如下三种类型：</p><blockquote><p><code>Greyhound ≼ Dog ≼ Animal</code></p></blockquote><p><code>Greyhound</code> （灰狗）是 <code>Dog</code> （狗）的子类型，而 <code>Dog</code> 则是 <code>Animal</code> （动物）的子类型。由于子类型通常是可传递的，因此我们也称 <code>Greyhound</code> 是 <code>Animal</code> 的子类型。</p><p><strong>问题</strong>：以下哪种类型是 <code>Dog → Dog</code> 的子类型呢？</p><ol><li><code>Greyhound → Greyhound</code></li><li><code>Greyhound → Animal</code></li><li><code>Animal → Animal</code></li><li><code>Animal → Greyhound</code></li></ol><p>让我们来思考一下如何解答这个问题。首先我们假设 <code>f</code> 是一个以 <code>Dog → Dog</code> 为参数的函数。它的返回值并不重要，为了具体描述问题，我们假设函数结构体是这样的： <code>f : (Dog → Dog) → String</code>。</p><p>现在我想给函数 <code>f</code> 传入某个函数 <code>g</code> 来调用。我们来瞧瞧当 <code>g</code> 为以上四种类型时，会发生什么情况。</p><p><strong>1. 我们假设 <code>g : Greyhound → Greyhound</code>， <code>f(g)</code> 的类型是否安全？</strong></p><p>不安全，因为在f内调用它的参数<code>(g)</code>函数时，使用的参数可能是一个不同于灰狗但又是狗的子类型，例如 <code>GermanShepherd</code> （牧羊犬）。</p><p><strong>2. 我们假设 <code>g : Greyhound → Animal</code>， <code>f(g)</code> 的类型是否安全？</strong></p><p>不安全。理由同(1)。</p><p><strong>3. 我们假设 <code>g : Animal → Animal</code>， <code>f(g)</code> 的类型是否安全？</strong></p><p>不安全。因为 <code>f</code> 有可能在调用完参数之后，让返回值，也就是 <code>Animal</code> （动物）狗叫。并非所有动物都会狗叫。</p><p><strong>4. 我们假设 <code>g : Animal → Greyhound</code>， <code>f(g)</code> 的类型是否安全？</strong></p><p>是的，它的类型是安全的。首先，<code>f</code> 可能会以任何狗的品种来作为参数调用，而所有的狗都是动物。其次，它可能会假设结果是一条狗，而所有的灰狗都是狗。</p><h2 id="展开讲讲" tabindex="-1"><a class="header-anchor" href="#展开讲讲"><span>展开讲讲？</span></a></h2><p>如上所述，我们得出结论：</p><blockquote><p><code>(Animal → Greyhound) ≼ (Dog → Dog)</code></p></blockquote><p>返回值类型很容易理解：灰狗是狗的子类型。但参数类型则是相反的：动物是狗的<em>父类</em>！</p><p>用合适的术语来描述这个奇怪的表现，可以说我们允许一个函数类型中，返回值类型是<em>协变</em>的，而参数类型是<em>逆变</em>的。返回值类型是协变的，意思是 <code>A ≼ B</code> 就意味着 <code>(T → A) ≼ (T → B)</code> 。参数类型是逆变的，意思是 <code>A ≼ B</code> 就意味着 <code>(B → T) ≼ (A → T)</code> （ <code>A</code> 和 <code>B</code> 的位置颠倒过来了）。</p>',23),b=t("strong",null,"一个有趣的现象",-1),y=t("code",null,"TypeScript",-1),u={href:"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant",target:"_blank",rel:"noopener noreferrer"},f={href:"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html",target:"_blank",rel:"noopener noreferrer"},_=t("code",null,"TypeScript 2.6",-1),v=t("code",null,"--strictFunctionTypes",-1),A=t("code",null,"--strict",-1),T=n('<h2 id="那其他类型呢" tabindex="-1"><a class="header-anchor" href="#那其他类型呢"><span>那其他类型呢？</span></a></h2><p><strong>问题</strong>：<code>List&lt;Dog&gt;</code> 能否为 <code>List&lt;Animal&gt;</code> 的子类型？</p><p>答案有点微妙。如果列表是不可变的（immutable），那么答案是肯定的，因为类型很安全。但是假如列表是可变的，那么答案绝对是否定的！</p><p>原因是，假设我需要一串 <code>List&lt;Animal&gt;</code> 而你传给我一串 <code>List&lt;Dog&gt;</code>。由于我认为我拥有的是一串 <code>List&lt;Animal&gt;</code> ，我可能会尝试往列表插入一只 <code>Cat</code>。那么你的 <code>List&lt;Dog&gt;</code> 里面就会有一只猫！类型系统不应该允许这种情况发生。</p><p>总结一下，我们可以允许不变的列表（immutable）在它的参数类型上是协变的，但是对于可变的列表（mutable），其参数类型则必须是不变的（invariant），既不是协变也不是逆变。</p>',5),w=t("strong",null,"一个有趣的现象",-1),S=t("code",null,"Java",-1),x={href:"https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29#Covariant_arrays_in_Java_and_C.23",target:"_blank",rel:"noopener noreferrer"};function q(j,B){const o=s("ExternalLinkIcon");return c(),a("div",null,[d,t("blockquote",null,[t("p",null,[t("a",p,[e("原文链接: what are covariance and contravariance"),i(o)])])]),t("p",null,[t("a",m,[e("子类型"),i(o)]),e(" 在编程理论上是一个复杂的话题，而他的复杂之处来自于一对经常会被混淆的现象，我们称之为"),g,e("与"),h,e("。这篇文章将会解释上述两个概念。")]),k,t("p",null,[b,e("：在 "),y,e(" 中， "),t("a",u,[e("参数类型是双向协变的"),i(o)]),e(" ，也就是说既是协变又是逆变的，而这并不安全。但是现在你可以在 "),t("a",f,[_,i(o)]),e(" 版本中通过 "),v,e(" 或 "),A,e(" 标记来修复这个问题。")]),T,t("p",null,[w,e("：在 "),S,e(" 中，数组"),t("a",x,[e("既是可变的，又是协变的"),i(o)]),e("。当然，这并不安全。")])])}const D=l(r,[["render",q],["__file","covarianceAndContravariance.html.vue"]]),G=JSON.parse('{"path":"/git/ts-book/docs/tips/covarianceAndContravariance.html","title":"协变与逆变","lang":"zh-CN","frontmatter":{"description":"协变与逆变 原文链接: what are covariance and contravariance 子类型 在编程理论上是一个复杂的话题，而他的复杂之处来自于一对经常会被混淆的现象，我们称之为协变与逆变。这篇文章将会解释上述两个概念。 开始文章之前我们先约定如下的标记： A ≼ B 意味着 A 是 B 的子类型。 A → B 指的是以 A 为参数类型...","head":[["meta",{"property":"og:url","content":"https://jjaw.cn/git/ts-book/docs/tips/covarianceAndContravariance.html"}],["meta",{"property":"og:site_name","content":"神奇小破站"}],["meta",{"property":"og:title","content":"协变与逆变"}],["meta",{"property":"og:description","content":"协变与逆变 原文链接: what are covariance and contravariance 子类型 在编程理论上是一个复杂的话题，而他的复杂之处来自于一对经常会被混淆的现象，我们称之为协变与逆变。这篇文章将会解释上述两个概念。 开始文章之前我们先约定如下的标记： A ≼ B 意味着 A 是 B 的子类型。 A → B 指的是以 A 为参数类型..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2021-01-06T13:56:29.000Z"}],["meta",{"property":"article:modified_time","content":"2021-01-06T13:56:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"协变与逆变\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2021-01-06T13:56:29.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"一个有趣的问题","slug":"一个有趣的问题","link":"#一个有趣的问题","children":[]},{"level":2,"title":"展开讲讲？","slug":"展开讲讲","link":"#展开讲讲","children":[]},{"level":2,"title":"那其他类型呢？","slug":"那其他类型呢","link":"#那其他类型呢","children":[]}],"git":{"externalRepo":{"url":"https://github.com/jianjianai/typescript-book-chinese","branch":"master"},"createdTime":1541691002000,"updatedTime":1609941389000,"contributors":[{"name":"zhazheng","email":"512557403@qq.com","commits":2},{"name":"Aaron Xie","email":"xieqiang9408@gmail.com","commits":1},{"name":"Tao Huang","email":"ht.anglenx@gmail.com","commits":1},{"name":"Will Wang","email":"willww64@gmail.com","commits":1},{"name":"chenfeng","email":"profbramble@gmail.com","commits":1},{"name":"jkchao","email":"jkchaom@gmail.com","commits":1},{"name":"康东扬","email":"kang_xjtu@163.com","commits":1}]},"excerpt":"\\n<blockquote>\\n<p><a href=\\"https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">原文链接: what are covariance and contravariance</a></p>\\n</blockquote>\\n<p><a href=\\"https://en.wikipedia.org/wiki/Subtyping\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">子类型</a> 在编程理论上是一个复杂的话题，而他的复杂之处来自于一对经常会被混淆的现象，我们称之为<em>协变</em>与<em>逆变</em>。这篇文章将会解释上述两个概念。</p>","autoDesc":true,"github_edit":{"fileGitUrl":"https://github.com/jianjianai/typescript-book-chinese/edit/master/docs/tips/covarianceAndContravariance.md"},"navPage":[{"title":"写在前面","items":[{"link":"/git/ts-book/docs/","title":"深入理解 TypeScript"}]},{"title":"TypeScript 项目","items":[{"link":"/git/ts-book/docs/project/compilationContext.html","title":"编译上下文"},{"link":"/git/ts-book/docs/project/declarationspaces.html","title":"声明空间"},{"link":"/git/ts-book/docs/project/modules.html","title":"模块"},{"link":"/git/ts-book/docs/project/namespaces.html","title":"命名空间"},{"link":"/git/ts-book/docs/project/dynamicImportExpressions.html","title":"动态导入表达式"}]},{"title":"TypeScript 类型系统","items":[{"link":"/git/ts-book/docs/typings/overview.html","title":"概览"},{"link":"/git/ts-book/docs/typings/migrating.html","title":"从 JavaScript 迁移"},{"link":"/git/ts-book/docs/typings/types.html","title":"@types"},{"link":"/git/ts-book/docs/typings/ambient.html","title":"环境声明"},{"link":"/git/ts-book/docs/typings/interfaces.html","title":"接口"},{"link":"/git/ts-book/docs/typings/enums.html","title":"枚举"},{"link":"/git/ts-book/docs/typings/lib.html","title":"lib.d.ts"},{"link":"/git/ts-book/docs/typings/functions.html","title":"函数"},{"link":"/git/ts-book/docs/typings/callable.html","title":"可调用的"},{"link":"/git/ts-book/docs/typings/typeAssertion.html","title":"类型断言"},{"link":"/git/ts-book/docs/typings/freshness.html","title":"Freshness"},{"link":"/git/ts-book/docs/typings/typeGuard.html","title":"类型保护"},{"link":"/git/ts-book/docs/typings/literals.html","title":"字面量类型"},{"link":"/git/ts-book/docs/typings/readonly.html","title":"readonly"},{"link":"/git/ts-book/docs/typings/generices.html","title":"泛型"},{"link":"/git/ts-book/docs/typings/typeInference.html","title":"类型推断"},{"link":"/git/ts-book/docs/typings/typeCompatibility.html","title":"类型兼容性"},{"link":"/git/ts-book/docs/typings/neverType.html","title":"Never"},{"link":"/git/ts-book/docs/typings/discrominatedUnion.html","title":"辨析联合类型"},{"link":"/git/ts-book/docs/typings/indexSignatures.html","title":"索引签名"},{"link":"/git/ts-book/docs/typings/movingTypes.html","title":"流动的类型"},{"link":"/git/ts-book/docs/typings/exceptionsHanding.html","title":"异常处理"},{"link":"/git/ts-book/docs/typings/mixins.html","title":"混合"},{"link":"/git/ts-book/docs/typings/thisType.html","title":"ThisType"}]},{"title":"JSX","items":[{"link":"/git/ts-book/docs/jsx/support.html","title":"支持 JSX"},{"link":"/git/ts-book/docs/jsx/reactJSX.html","title":"React JSX"},{"link":"/git/ts-book/docs/jsx/nonReactJSX.html","title":"非 React JSX"}]},{"title":"TypeScript 错误提示","items":[{"link":"/git/ts-book/docs/error/interpreting.html","title":"解读 Errors"},{"link":"/git/ts-book/docs/error/common.html","title":"常见的 Error"}]},{"title":"TIPs","items":[{"link":"/git/ts-book/docs/tips/stringBasedEmuns.html","title":"基于字符串的枚举"},{"link":"/git/ts-book/docs/tips/nominalTyping.html","title":"名义化类型"},{"link":"/git/ts-book/docs/tips/statefulFunctions.html","title":"状态函数"},{"link":"/git/ts-book/docs/tips/bind.html","title":"Bind 是有害的"},{"link":"/git/ts-book/docs/tips/curry.html","title":"柯里化"},{"link":"/git/ts-book/docs/tips/typeInstantiation.html","title":"泛型的实例化类型"},{"link":"/git/ts-book/docs/tips/lazyObjectLiteralInitialization.html","title":"对象字面量的惰性初始化"},{"link":"/git/ts-book/docs/tips/classAreUseful.html","title":"类是有用的"},{"link":"/git/ts-book/docs/tips/avoidExportDefault.html","title":"export default 被认为是有害的"},{"link":"/git/ts-book/docs/tips/limitPropertySetters.html","title":"减少 setter 属性的使用"},{"link":"/git/ts-book/docs/tips/createArrays.html","title":"创建数组"},{"link":"/git/ts-book/docs/tips/outFileCaution.html","title":"谨慎使用 --outFile"},{"link":"/git/ts-book/docs/tips/staticConstructors.html","title":"TypeScript 中的静态构造函数"},{"link":"/git/ts-book/docs/tips/singletonPatern.html","title":"单例模式"},{"link":"/git/ts-book/docs/tips/functionParameters.html","title":"函数参数"},{"link":"/git/ts-book/docs/tips/truthy.html","title":"Truthy"},{"link":"/git/ts-book/docs/tips/buildToggles.html","title":"构建切换"},{"link":"/git/ts-book/docs/tips/typesafeEventEmitter.html","title":"类型安全的 Event Emitter"},{"link":"/git/ts-book/docs/tips/metadata.html","title":"Reflect Metadata"},{"link":"/git/ts-book/docs/tips/covarianceAndContravariance.html","title":"协变与逆变"},{"link":"/git/ts-book/docs/tips/infer.html","title":"infer"}]},{"title":"TypeScript 编译原理","items":[{"link":"/git/ts-book/docs/compiler/overview.html","title":"概览"},{"link":"/git/ts-book/docs/compiler/program.html","title":"程序"},{"link":"/git/ts-book/docs/compiler/ast.html","title":"抽象语法树"},{"link":"/git/ts-book/docs/compiler/scanner.html","title":"扫描器"},{"link":"/git/ts-book/docs/compiler/parser.html","title":"解析器"},{"link":"/git/ts-book/docs/compiler/binder.html","title":"绑定器"},{"link":"/git/ts-book/docs/compiler/checker.html","title":"检查器"},{"link":"/git/ts-book/docs/compiler/emitter.html","title":"发射器"}]},{"title":"TypeScript FAQs","items":[{"link":"/git/ts-book/docs/faqs/common-bug-not-bugs.html","title":"一些常见的「bug」并不是 bug"},{"link":"/git/ts-book/docs/faqs/common-feature-request.html","title":"一些常见的 Feature 需求"},{"link":"/git/ts-book/docs/faqs/type-system-behavior.html","title":"类型系统的行为"},{"link":"/git/ts-book/docs/faqs/function.html","title":"函数"},{"link":"/git/ts-book/docs/faqs/class.html","title":"类"},{"link":"/git/ts-book/docs/faqs/generics.html","title":"泛型"},{"link":"/git/ts-book/docs/faqs/modules.html","title":"模块"},{"link":"/git/ts-book/docs/faqs/enums.html","title":"枚举"},{"link":"/git/ts-book/docs/faqs/type-guards.html","title":"类型守卫"},{"link":"/git/ts-book/docs/faqs/jsx-and-react.html","title":"JSX 和 React"},{"link":"/git/ts-book/docs/faqs/thing-that-dont-work.html","title":"一些不能按预期工作的代码"},{"link":"/git/ts-book/docs/faqs/commandline-behavior.html","title":"命令行的行为"},{"link":"/git/ts-book/docs/faqs/tsconfig-behavior.html","title":"tsconfig.json 的行为"}]},{"title":"TypeScript 更新","items":[{"link":"/git/ts-book/docs/new/typescript-3.9.html","title":"TypeScript 3.9"},{"link":"/git/ts-book/docs/new/typescript-3.8.html","title":"TypeScript 3.8"},{"link":"/git/ts-book/docs/new/typescript-3.7.html","title":"TypeScript 3.7"}]}]}');export{D as comp,G as data};
